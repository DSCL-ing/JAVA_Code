package 笔记;

import java.util.Arrays;
import java.util.Scanner;

//import 只能导入类,不能导入包

/** 笔记.Note
 * from,to  -----> 左闭右开
 *
 * 数组没有-1下标,一般不满足的返回值为-1,也可能是负数的随机值
 *
 * 引用类型如果还未知初始化值时,赋值null;说明不指向任何对象
 *
 * 局部变量优先使用(Java中没有全局变量)  --- 静态变量属于"全局变量"一种,局部优先原则,有局部会屏蔽全局
 * 方法中不能使用static,本意是共享变量,方法中定义则矛盾,故语法不支持
 *
 * package 表明哪个包
 *
 * 常量是在程序编译时就已确定的.final --- 能实现很多不能的操作
 *
 * 学一个类，要从构造方法开始
 *
 * jdk反汇编工具 javap: javap -c 类名称
 */

//一些方法

/**
 * Character.isDigit(ch):判断字符是否是数字
 * Characher.isLetter(ch):判断字符是否是字母
 *  0-9 , a-z
 *
 */


public class Note {

    public void note() {

        //**********************************************
        //native 本地方法
        /**
         * 特点:底层是由C/C++实现的,相关代码无法查看
         */

        //**********************************************
        //局部变量
        /**
         * java中局部变量必须初始化
         */

        //**********************************************
        //        import java.util.Scanner;
        //Scanner(从键盘读入,scnaf)
        Scanner scan_name = new Scanner(System.in);
        int n = scan_name.nextInt();

        //****
        //此时下边不能接字符串，因为回车还在，会被字符串读取
        //解决，在之前再来个字符串读取
        {
            String str = scan_name.next();
            String str1 = scan_name.nextLine();
        }

        //****循环
        {
            while (scan_name.hasNextInt()) {  //必定进入循环，如果是整型，循环继续
                int n1 = scan_name.nextInt();
                System.out.println("n = " + n);
            }
        }
        //结束：control + D


        //********************************************************************************
        //方法的创建
            public static 返回值 方法名 (形式参数列表) {
                方法体
        }

        //方法的调用
        方法名(参数名列表);
        //方法放在哪:类里面,main函数上面下面都行
        //方法不用声明;C语言要声明
        //方法不能嵌套;  ?
        //方法命名:小驼峰
        //修饰符:现阶段用public static 固定搭配

        //重载
        //功能:能够建立方法名一样参数数量、类型不一样的方法,避免了C语言中同一功能不同参数时要建立多个函数的麻烦.
        //实现重载：
        /**
         * 1、方法名称必须相同
         * 2、方法的参数列表必须不同
         * 3、和返回值没有关系 ---- 返回值是什么都行
         */

        //重载的特殊用法:add(int... aaa){} // 必须3个.
        /** add(1,2,3,44,5,5,5,5,5);
         *  语法:可变参数,自动识别参数并匹配.可读性不高
         *
         */



        //********************************************************************************
        //数组(引用类型)
        {
         /**
         * 数组的使命是用来存储一组相同数据类型的数据
         */
            //new关键字：一般通过new关键字来实例化对象 ---- java中一切皆对象 ---- java中数据就是一个对象
            /*数组定义和使用*/
            /*方法1*/ int[] arr1 = {1, 2, 3, 4, 5, 6};          //方法2的省略形式
            /*方法2*/ int[] arr2 = new int[]{1, 2, 3, 4, 5, 6}; //大小会自动计算分配,[]中不能写任何数字
            /*方法3*/ int[] arr3 = new int[10];                 //初始值为0 --- 没有初始化,只是分配了内存 --之后只能一个一个元素赋值
            /**
             * 没有初始化时,boolean值为false,char型值为'/u0000'(不可打印/显示),其他为0
             */

            /*方法4*/ int[] arr4; arr4 = new int[]{1, 2, 3, 4, 5, 6};//可以分开写
            /*       int[] arr5; arr5 = {1,2,3,4,5,6};  */     //不能省略 new_类型

            //拓展:字符串类型也是引用类型,只是一般习惯简写
            /*方法1*/ String str1 = new String("hello"); //标准
            /*方法2*/ String str2 = "hello";                     //方法1的省略形式

            //求数组长度：array.length
            {
                int[] array = {1, 4, 6, 3, 8, 5};
                System.out.println(array.length);
            }

            //数组的遍历
            /*方法1*/ //通过下标来访问
            for (int i = 0; i < array.length; i++) {
                System.out.println(array[i]);
            }
            /*方法2*/ //for-each循环 (for增强版) --- 与下标无关
            for (int x : array) {
                System.out.println(x);
            }

            /*方法3*/ //使用方法toString 把数组所有数据转换成字符串输出
            /* import java.util.Arrays; */
/*            {
                String ret = Arrays.toString(array);
                System.out.println(ret);
            }*/

            //数组的拷贝
            /**
             * 深/浅拷贝
             * 浅拷贝:如果修改array2的值影响array1,则为浅拷贝
             * 深拷贝:如果修改array2的值不影响array1,则为深拷贝
             * 深/浅拷贝只和实现方式有关,与循环等无关...
             */

            /* 方法拓展:   */
            //1.Arrays.toString(array):将数组转化成字符串类型 --- myToString
/*            {
                System.out.println(Arrays.toString(array));
            }*/
            //2.Arrays.sort(array):排序数组元素;
            {
                Arrays.sort(array);
                System.out.println(ret);
            }
            //3.Arrays.copyOf(原数组,新数组的长度):拷贝数组 --- myArrayCopy
            {
                int[] tmp = Arrays.copyOf(array,array.length);//拷贝
                int[] tmp1 = Arrays.copyOf(array, array.length * 2);//扩容

            //3_1.System.arracopy//本地方法
                /**
                 * (Object src, int srcPos, Object dest, int destPos, int length)
                 * src:原数组  srcPos:拷贝位置 ...        length:要拷贝的长度
                 */
            //3_2.Arrays.copyOfRange(原数组,from,to) //[from,to) --- 左闭右开

            //3_3.Arrays.equals(array1,array2);    // 比较两个数组是否相等,返回boolean值

            //3_4.Arrays.fill(array,val);// val:需要填充的值 ---- 給数组所有元素赋一个相同的值
            //3_5.Arrays.fill(array,from,to,val); // 局部填充,左闭右开
            }

            /* 拓展: 引用类型             */
            /**
             * JVM对内存的划分(java虚拟机运行时数据区),(逻辑上)
             * 1.java虚拟机栈(Java Stack); 2.堆（Heap）; 3.本地方法栈(Native Method Stack); 4.方法区(Method Area); 5.程序计数器(Program Counter Register);
             * 其中Java虚拟机栈就是平时使用的栈(Stack)
             * 为什么数组是引用类型?
             * a.局部变量一般存在栈上 --- 就是在方法内部定义的变量
             * b.数组引用的数据存放在堆上(只要是通过new xxx 就存在堆上 --- 'new')
             * c.数组是局部变量,存放在栈上,数组存放的是数据的地址.
             * d.数组通过数组存放的地址引用了对应地址上的数据
             * 存了地址的变量,就称作引用变量
             * 如果直接对数组名打印,则会输出：[I@1b6d3586; 其中'['中括号代表组数。 'I'I代表int,整型。 @为分隔符 。后面一串1b6d3586暂且可以看作地址
             *
             * 方法区其实在堆上
             *
             */

            //数组本身的地址在java中取不到

            //null
            //引用类型如果还未知初始化值时,赋值null;说明不指向任何对象
            {
                int[] array1 = null; //描述:array1这个引用不指向任何对象   --- c语言null指向0号地址,是受保护的范围.
                System.out.println();//输出为'null';
            }
            //NPE问题(NullPointerException) 空指针异常
            /**
             * 问题出现:引用了一个空指针null,野指针
             * 解决方法:
             * 根据提示的行号,找一个引用,看下为什么是null.--- 唯一
             */

            //如果对象没有被引用,则会被系统自动回收

            //返回数组类型
/*            public static int[] fun10() {
                int[] tmpArr = {1, 2, 3};
                return tmpArr;
            }
*/

            //java中数组可以用变量标识数组大小 --- c语言只能用常量

            //--------------------------------------------------------------------------------------
            //二维数组
            /* 二维数组的定义和使用 */
            /*方法1*/ int[][] array1 = {{1, 2, 3}, {4, 5, 6}};
            /*方法2*/ int[][] array2 = new int[][]{{1, 2, 3}, {4, 5, 6}};
            /*方法3*/ int[][] array3 = new int[2][3];

            /**
             * 一、java的二维数组可以不连续
             * 1.java的二维数组的每一行中的元素都是连续的
             * 2.java用一个一维数组存放了各个行的的首地址
             * java的二维数组是用一个存放各行首地址的一维数组和存放各行元素的多个一维数组构成
             *
             * 二、Java的二维数组是不规则数组
             * 1.java的二维数组可以不指定列数(必须要指定行数)
             * 2.java的每一行的列数可以不相同
             */
            //不规则定义
            {
                int[][] array = new int[2][];
                System.out.println(array[0]); //null
                System.out.println(array[1]); //null
                array[0] = new int[2];
                array[1] = new int[4];
                System.out.println(array[0]); //[I@1b6d3586
                System.out.println(array[1]); //[I@4554617c
            }

            //二维数组的长度
            {
                int[][] array = {{1, 2, 3}, {4, 5, 6}};
                System.out.println(array.length);      //数组的行数
                System.out.println(array[1].length);   //数组的列数
            }

            /* 二维数组的遍历 */
            /*方法1*/ //for循环
            {
                int[][] array = {{1, 2, 3}, {4, 5, 6}};
                for (int i = 0; i < array.length; i++) {
                    for (int j = 0; j < array[i].length; j++) {
                        System.out.print(array[i][j] + " ");
                    }
                    System.out.println();
                }
            }
            /*方法2*/ //for-each循环
            {
                int[][] array = {{1, 2, 3}, {4, 5, 6}};
                for (int[] ret : array) {
                    for (int x : ret) {
                        System.out.print(x + " ");
                    }
                    System.out.println();
                }
            }
            /*方法3*/ // Arrays.deepToString(array);
            {
                int[][] array = {{1, 2, 3}, {4, 5, 6}};
                System.out.println(Arrays.deepToString(array));
            }
        }

        //********************************************************************************
        //对象(java中一切皆对象)、类
        {
            //概念
            /**
             * 面向对象编程 Obeject Oriented Program(OOP)
             * 面向对象是一种解决问题的思想,主要依靠对象(实体)之间的交互完成一件事情.
             */

            /**
             * 实体 --- 对象(实际就是一个实体)
             * 一般来说,一个java文 件只有一个类
             * 类名用大驼峰定义
             * 成员变量和成员方法前先统一public,且不带static
             * 一个java文件只能有一个public修饰的类,且public修饰的类的名字必须和文件名相同
             *
             *通过关键字new实例化对象,同一个类可以创建多个实例
             *通过.来访问对象中的属性和方法
             * 类包含属性/成员变量 和 行为/成员方法
             *
             *
             *   实例化后:对象名(引用类型)存放在栈上,成员变量存放在堆,成员方法存放在方法区(没调用不占内存,只存放信息),方法内的变量在栈(和局部变量)
             * --未实例都在方法区
             *
             * 成员变量实例化后可以不初始化,有默认值为null或0,boolean是false,char是'/u0000'
             *
             * 定义类的时 给成员变量赋值会写死. 不建议
             */

            /*生命周期*/
            /**
             * 成员变量:类创建 --- 类销毁结束
             * 局部变量:方法创建 -- 方法销毁结束
             */

            //this
            /**
             * 每个成员方法默认隐藏有一个参数:方法名 this,
             *
             * this是什么?　this是指明调用当前方法的对象的关键字
             *
             * this引用的是当前调用方法的对象
             *
             * this的类型名是类名
             *
             * 静态方法中不能使用this --- 不是由对象调用的!不知道是哪个对象,不需要对象
             * 静态方法中不能直接调用非静态方法的成员变量,
             *
             */


            //实例化对象后为什么不用初始化?
            //引入构造方法:对ClassUtil classUtil = new 类.ClassUtil(); 分析
            //
            //构造方法:帮助包括子类和父类初始化
            /**
             * 什么是构造方法:构造方法是特殊的方法,'无返回类型'(void也不行),方法名和类名相同
             * 可以没有参数和方法体
             *
             *
             * 存在形式:如果类方法中不带'任何的'构造方法,则Java默认会自动创建(提供)一个不带参数和方法体的构造方法
             * 所以用new实例化对象时,一定会调用构造方法 ---- 没有构造方法一定会报错 ---->构造方法是类的必要组成
             *  如果自己创建了构造方法,则优先使用创建的构造方法 -- 注意!!! 必须有一个不带参数的构造方法
             *
             * 如何使用:构造方法在创建对象时,由编译器自动调用,并且只会调用一次(整个对象的生命周期内只调用一次)
             *
             * 可以有多个构造方法,这些构造方法构成重载(方法名相同,参数列表不同,返回值没有影响)
             *  构造方法不能写返回值,参数列表可以不同,满足重载
             *
             * 构造方法和其他方法一样,会调用相同参数的构造方法(参数匹配才执行)
             */

            //※new的实例化过程(初略了解)
            /**
             * 1.检测对象对应的类是否加载,如果没有加载则加载 ....
             * 2.为对象分配内存空间(包括设置初始值...)
             * 3.处理并发安全问题,比如:多个线程同时申请对象,JVM要保证给对象分配的空间不冲突
             * 4.初始化所分配的空间,即对象空间被申请好之后,给对象中包含的成员设置初始值
             * 5.设置对象头信息
             * 6.调用对象的构造方法,给对象成员初始化
             */

            //构造中的this
            /**
             * 在调用构造方法前,new已经为对象分配了内存空间,所以可以使用this
             *
             * 常规使用:通过this访问成员变量或成员方法
             * 1.this.data:访问当前对象的成员变量
             * 2.this.func():访问当前对象的成员方法
             * 3.this():调用当前对象的其他构造方法
             * 注:不能调用静态的成员方法和属性
             * this的特殊使用:
             * 在构造方法的第一行写'this(实际参数列表);'可以调用匹配的构造方法
             * --- 1.必须放在构造方法的第一行,其他方法不行
             * --- 2.不能形成环(不能死锁)
             *
             */

        }

        /*IDEA自动生成插入构造方法*/
        /**
         * 类空白处右击,选择Genarate(Alt+Insert),constructor,然后选择需要的成员变量,OK
         */
        /*IDEA自动生成插入对外接口*/
        /**
         * 类空白处右击,选择Genarate(Alt+Insert),Getter/ and /Setter, 然后选择需要的成员变量,OK
         */

        /*                                    示例                           */
/*          public class 类.ClassUtil {
                public int year;
                public int month;
                public int day;

                public 类.ClassUtil() {
                    this(3,3,3); //this必须放在第一行
                    System.out.println("调用了不带参数的构造方法");
                }

                public 类.ClassUtil(int year, int month, int day) {
                    this.year = year;
                    this.month = month;
                    this.day = day;
                    //day = 1999;   //不能这么写
                    show();
                    System.out.println("调用了带3个参数的构造方法");
                }

                public void setDate(类.ClassUtil this, int year, int month, int day) {
                    {
                        year = year;
                        month = month;
                        day = day;
                        //错误! 如果不用this指明,根据'局部变量优先使用'规则,=号两边都是相同的局部变量,即自己给自己赋值,没有给对象赋值.
                    }

                    {
                        this.year = year;
                        this.month = month;
                        this.day = day;
                    }
                    //局部变量优先
                }

                public void show(类.ClassUtil this) {
                    System.out.println(this.year + "-" + this.month + "- " + this.day + "");
                }

                public static void main(String[] args) {
                    类.ClassUtil classUtil = new 类.ClassUtil();

                }
            }*/


        //********************************************************************************
        //封装
        {
            /*前序*/
            /**
             * 面向对象程序三大特性:封装、继承、多态。而类和对象阶段主要是封装特性。何为封装？：套壳屏蔽细节，把类的实现细节隐藏，对外只提供一些交互的接口
             * 封装的定义：把数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口用来和对象进行交互
             */

            /*访问修饰限定符（权限）*/
            /**
             * java权限：1.private   2.默认权限(default)   3.protected    4.public
             * private:只能在同一个类中使用
             * default:包访问权限:同一包中不同类可使用
             * protected:不同包的类只能通过super访问(继承关系)
             * 权限:应尽可能使用比较严格的访问权限,如果一个方法能用private,就尽量不要用public
             *
             *
             */

            /*封装扩展 --- 包*/
            /**
             * 包的概念:为了更好的管理类,把多个类收集在一起成为一组,称为软件包
             * java中包是对类,接口等的封装的体现,是一种对类或者接口库等的很好的组织方式.
             * 如一个工程中允许存在相同名称的类,只要处在不同的包中即可
             *
             * -----其实就是文件夹
             *
             *
             * 包(import java.*.*) 是随用随取,用到哪个类就导入哪个类,不会把所有都导进来(C语言全部导入)
             * 包(import static java.*.*) 带static的是导入了所有,也是随用随取 ,这种在用的时候可以省略类名,如Math.sqtr可以直接sqrt
             *
             */

            /*自定义包*/
            /**
             * IDEA方法:右击src,选new-package,命名风格为 域名的颠倒形式: com.test.www
             * IDEA修改包显示方法:点Show Options Menu -Tree Appearance -选择不同显示方式
             *
             * package定义:package语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包。
             */

            /*常用的包*/
            /**
             * 1.java.lang:系统常用基础类(String、Object),从JDK1.1开始自动导入
             * 需要手动导入的包:
             * 2.java.lang.reflect:java 反射编程包;
             * 3.java.net:进行网络编程开发包
             * 4.java.sql:进行数据库开发的支持包
             * 5.Java.util:是Java提供的工具程序包.(集合类等)非常重要
             * 6.Java.io:I/O编程开发包
             */

        }

        //********************************************************************************
        //静态成员(static成员)
        /**
         * java中,被static修饰的成员变量,被称为静态成员变量,
         * 静态成员变量不属于某个具体的对象,所有对象共享.
         *
         * 从这开始成员变量要分为'静态成员变量'和'非静态成员变量'.
         * 静态成员变量也可称为'类成员' 或者 '类变量'
         * 非静态成员变量也可称为'普通成员变量'
         *
         * 访问静态成员变量:通过类名访问(普通成员变量是通过对象来访问的),也可以通过对象来访问,不推荐
         * 如果通过对象来访问，必须手写，不能通过.来访问
         * 不用实例化对象也可以输出
         *
         * 特点：不依赖于对象！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
         * 即使不指向任何对象，也不影响访问成员变量
         * 即Class.xxx = null ; xxx.static变量;不会报错，可以正常访问
         *
         * 引出：公共属性时使用，不必重复
         *
         * 生命周期：类销毁而销毁
         *
         * 不能在方法中定义static变量(语法不支持,编译失败)
         */

        //静态方法
        /**
        * 静态方法中不能使用this --- 不是由对象调用的!不知道是哪个对象,不需要对象
        * 静态方法中不能直接调用非静态方法的成员变量,
         * 如果是静态成员,则对应方法也加上static,否则,使用非静态还要实例化
         */

        //静态成员初始化:
        /**
         * 1.直接赋值 2.默认值为0 3.get或set 方法
         */

        //static
        /**
         * 非静态方法中不能使用静态变量,因为静态不依赖于类,而方法依赖,矛盾
         * =>非静态内部类(不能有静态成员,除非加final) === 非静态方法
         */

        //有关static索引
        /**
         * 代码块
         */

        }

    //********************************************************************************
    //代码块
    {
        {
            //无需条件执行
            System.out.println("普通代码块!");
        }

        Class test1 {
        {

            System.out.println("非静态代码块/实例代码块/构造代码块!->初始化非静态的数据成员");
            /**
             *
             * 在类里面.执行在构造方法前,前后无所谓,用来给成员初始化
             * 实际就是合并到构造方法中,在前面第一行
             * 辅助不带参数的构造方法初始化,带参数则无效
             * 但是如果成员变量直接赋值,并且位置在实例代码块之后,则也无效
             * 实例代码块只会在实例化后才会被执行
             */
        }//知道就好,一般不会用

        static{
            System.out.println("静态代码块->初始化静态的数据成员/提前准备一些数据");
            /**
             * 静态代码块先执行,比非静态快
             * 不需要实例化,"只要类被加载",类被执行,就会执行静态代码块,并且只会执行一次(实例化多个对象也无影响),
             * 如果有多个静态代码块,则按顺序先后执行
             * (通过类名去访问静态变量也会执行静态代码块)
             */
        }
    }


        //********************************************************************************
        //继承和多态
        //继承 inheritance   //继承表示对象之间是is-a的关系:如狗是动物,猫是动物
        /**
         * 继承的意义是:对代码可以复用(抽象出相同的共性,实现代码服用)
         *
         * 修饰符可写可不写
         *
         * 一个子类只能继承一个父类,单继承(C++可以多继承)
         *
         * 继承可以构成重载
          *
         */

        //关键字:extends(和C语言的一样)
        /**
         * 继承语法:子类 extends 父类
         * 子类又叫派生(derived)类,父类又叫基类或超类
         */

        //子类访问父类成员变量(就近原则)
        /**
         * 1.子类和父类不存在同名变量(可以访问)
         *
         * 2.子类和父类存在同名变量(优先访问自己的)
         *
         * 3.通过关键字super引用父类(暂且,最大作用是体现代码可读性)
         * super.method   super.variable   --- this.代表当前对象,super.代表当前对象的父类
         *
         * super也和this一样不能在静态static方法下使用,因为都依赖于对象,需要实例化对象
         *
         * super只能指代直接的父类,不能指代爷爷类
         *
         * super:引用从父类继承下来的成员/方法的调用
         *
         * 可以继承父类的private,但是不能访问
         *
         * super和this一样不能在静态static中使用(一般借助func接口调用)
         *
         * super不代表父类的引用
         *
         */

        //调用父类构造方法前
        /**
         * 必须在子类前借助super将父类初始化,才能调用父类构造.
         * 顺序:public class_name{super(x.x),this(x,x)}
         * 一般会子类构造中会自动加入super()
         */


        //static,父类,子类  块/方法  的优先级
        /**
         * static父类->static子类->父类块->父类构造方法->子类块->子类构造方法
         * static->父类->子类
         * 优先级：
            父类的静态
            子类的静态
            父类的实例
            父类的构造方法
            子类的实例
            子类的构造方法
         */

        //多层继承和停止多层继承
        /**
         * 使用final关键字停止被继承,使当前类无法被继承
         * final也用来修饰变量,使变量转变为常量(变量名要大写)
         *
         * 成员变量也可以用final修饰,语法:public final int a = 199;//必须要有初始值
         */

        //组合:一种设计思想
        // 组合表示对象之间是has-a的关系,比如:汽车和其他零部件的关系
        /**
         * 一个类中成员变量可以有其他类的实例（在类中定义其他类的成员变量）
         */

        //多态：前提：
        //向上转型(发生多态的前提)
        /**
         * 父类引用引用子类对象
         *
         * 实现方法:
         * 1.传参(参数为父类,子类为形参)
         * 2.返回类型为父类(返回值为子类)
         * 3.父类引用接收子类对象(通用)
         *
         * 父类能实例化子类,父类能访问子类中 父类自己的成员(继承下来的) ,不能访问子类特有的成员
         *
         * 向上转型有3种
         * 1.父类类型直接引用 2.父类类型形参接收引用 3.返回值是父类类型，返回值是子类
         *
         * 多态发生的前提
         *
         * 通过父类引用调用父类的方法和子类重写的方法(动态绑定)
         *
         *
         *
         *
         * 缺点:只能引用父类自己的成员和方法
         */

        //向下转型(不安全)
        /**
         * 将父类对象强制转换成子类实例
         * 类.Dog dog = (类.Dog)animall;
         *
         * 动物可以是狗,动物可以是鸟,但狗不能是鸟,如果动物是狗,那动物就不能是转换成鸟(编译没错,执行报错)
         */

        //检查向下转型关键字:instanceof //用于判断父类接收到的子类是否匹配,类似equals
        /** 向下转型:               //实现多态,无需知道对象是谁,接收到能匹配上就可使用
         * (父类名 instanceof 子类型)  //判断
         * 子类 子类名 = (子类)父类 //强制类型转换(强转),习惯,安全
         * 子类名.方法             //引用
         */

        //重写
        /**
         * 重写需满足3个条件:
         * 1.方法名称相同
         * 2.参数列表相同
         * 3.返回值相同
         *
         * 允许范围：
         * 1.private修饰的方法不能重写：只能在类中访问
         * 2.static修饰的方法不能重写，因为static属于类的方法
         * 3.子类的访问修饰限定权限要大于等于父类的权限：
         *
         * 快速重写:选中继承子类这一行(继承抽象类且没重写时报红),按alt+enter ,一路回车
         */

        //协变类型:父子类重载方法中返回值构成父子关系(java不支持子类返回值大于父类)

        //@Override
        // Override是注解,注解有很多种
        //生成方法:可以在generate中生成或旁边黄色灯泡
        /*@Override*/ //此处的Override意思是当前方法是被重写的

        //动态绑定
        /**
         *
         * 现象：自动跳转到子类。在编译时还不知调用什么，显示是父类，执行时调用子类。 动态 ---运行时
         * 前提：
         * 1.向上转型
         * 2.重写
         * 3.通过父类引用 调用这个父类和子类重写的方法
         * 先记结论：运行时自动调用重写的。
         *
         *
         */

        //静态绑定：重载等...在编译时已知道是哪个方法了

        //多态:是一种思想:对于不同对象,引用的方法和行为是不一样的 ----即看到的表象是不一样的,叫做多态
        /**
         *        当父类引用的对象不一样时,表现出的行为是不一样的
         * 使用多态的好处
         * 1.能够降低代码的“圈复杂度" , 避免使用大量的if-eles
         *       圈复杂度:是一种描述一段代码复杂程度的方式,如果分支/循环很多就认为理解起来复杂
         *       因此可以简单计算一段代码中条件语句和循环语句出现的个数,个数就称:"圈复杂度".\
         *       如果圈复杂度太高.就需要考虑重构,不同公司规范不一样,一般不超过10
         *
         */

        //多态缺点
        /**
         * 1.代码运行效率降低
         * 2.属性没有多态性(普通方法有):父类子类都有同名的属性时,通过父类引用只能引用父类自己的成员属性
         * 3.构造方法没有多态性,
         *      当在父类的构造方法中调用同名(重写)的方法时,则会调用子类的方法,此时如有调用继承的成员,将会使用继承的,乱
         */

        //********************************************************************************
        //抽象类
        {
           /*抽象类概念*/
            /**
             * 所有的对象都是通过类来描述的,但不是所有类都是用来描述对象的
             *  如果一个类中没有足够的信息来描绘一个具体的对象,就称为抽象类
             */

            //标志:关键字:abstract(abstract class name)

            //抽象类 特点
            /**
             * 1.抽象类 使用abstract修饰类
             * 2.抽象类不能被实例化
             * 3.抽象类中可以没有具体的方法体(抽象方法):public abstract void func(); ---- 没方法体
             * 4.作用:用来被继承,但必须重写抽象类中的抽象方法
             * 5.不能使用private修饰方法,因为抽象类要被继承,矛盾
             * 6.不能使用static和final,因为抽象类要重写
             * 7.可以没有抽象方法
             *
             * 抽象类本身不能被实例化,要想使用,只能创建改抽象类的子类,然后重写抽象类中的抽象方法
             * 像抽象类等语法存在的意义是为了'预防报错',和final等类似
             * 抽象类可以检查,提醒子类是否已重写抽象方法.普通类不检查
               */

        }


        //********************************************************************************
        //接口
        {
            /**\接口的概念:
             *
             * 接口:像usb,typec,插座 .行为上是一种规范,或是一种通用的标准/协议
             * 接口就是公共的行为规范标准,只要符合规范标准就可以通用
             * java中,接口可以看成是:多个类的公共规范,是一种引用数据类型
             * 接口是一种更↑的抽象类
             *
             * 接口表达的含义是具有xxx特性
             */

            //接口和抽象类不一样的是：抽象类是一个大类，接口表达的是大类中的其中一个的特性
            //单继承多接口的特性的好处是：让程序员忘记类型！

            //接口的定义:关键字:interface
            interfece IShape {   // --- 通常以大写字母I开头
                public abstract void draw ();
            }
            /**
             * 一般一个接口就是一个java文件,在file_new有选项
             *
             * 1.接口中的成员变量都是默认为 public static final ...(所以可以省略修饰,直接类型+名字)
             * 都是静态常量,必须要在定义时赋值
             * static修饰的成员变量字体是斜的
             *
             * 2.接口中的方法都是抽象方法,不能有方法体,具体实现
             * 接口中的方法默认都是public abstract .... (所以方法可以省略修饰)
             *
             * 3.从JDK8开始,提供了新特性,可以使用有具体实现的方法
             * 关键字:default  //加入关键字即可实现具体方法
             * default public void func(){//具体实现};
             *
             * 4.接口中不能有构造方法
             *
             * 5.如何使用接口?
             *  关键字:implements(实施,贯彻)      //class 类 implements 接口{}
             *  接口中的方法默认时抽象方法,所以使用时需要重写
             *  通过向上转型使用
             *
             * 6.接口中可以有static修饰的方法 --- 和普通类一样,可以通过类名(接口名)调用
             * public static void name(){//};
             *
             * 7.接口不能被实例化,必须要有要一个'实现类'来实现该接口或接口中的抽象方法
             */

            //接口的命名:
            /**
             * 1.一般以大写字母I开头
             * 2.一般使用形容词
             * 3.阿里编码规范中约定:接口的方法和属性不要加修饰符号(修饰关键字),保持代码整洁
             */

            //接口和抽象类
            /**
             * 抽象类是对一个事务在抽象
             * 接口是对一个行为或规范在设定标准 -- 设计思想(专业)
             */
              //特别使用:
              //java不支持多继承,所以有:
              //         --- 继承一个父类和多个接口 ---
              class 子类 extends 父类 implements 接口1,接口2...
            /**
             * 先继承再实现
             */

            //综合:
            /**
             * 一个抽象类,多个接口/规范,多个对象类,多个执行方法,一个main函数
             * 定义好规范:抽象类、接口和对象类
             * 执行方法:在public class中定义好要执行的方法,方法中调用相应接口
             * main方法:在main方法中实例化对象类,并通过向上转型调用执行方法...
             *
             */

            //接口之间的继承(接口的拓展---相当于多个接口合并)
            /**
             * 例:
             * interface A{}
             * interface B{}
             * interface C extends A,B{}  // 接口C 不仅具备自己的功能,还具备A和B接口的功能(拓展)
             * 调用接口C时,不仅需要重写C功能,还要重写A和B的功能
             */

            //cloneable接口 和 深拷贝
            //要克隆一个对象，一定要调用clonable接口
            /*空接口*/ // 也叫标记接口
            /**
             * cloneable空接口作用：表示当前对象 是可以被克隆的 ---cloneable的构造方法是空的
             */

            /*Object*/ //所有类的父类 --- 不论有没有继承

            //如何克隆一个类1(浅拷贝):
            /**
             * 重写Object类clone方法:构造(generate)->overrive methor(重写方法)->clone():Object;
             * 调用克隆方法并给新对象接收
             */

            //异常
            /**
             * 1.编译异常:报红,编译不过
             * 2.运行异常:不报红,运行时错误.
             */

            //处理异常
            /**
             * 将类方法名后面的throws连带后面的语法拷贝到main函数名后面的同样位置
             * 在clone中,处理异常后需要将调用clone的方法强转回被克隆类型.(因为clone调用的是Object类方法) ---
             *      因为父类赋给子类是向下转型，且不安全，需要强转，当然也有一定风险，一般需要前面加上instance判断继承关系
             */

            //深拷贝（和链表复制一样，层层拷贝，指向分离和复制，不能两个节点同时指向同一个对象）
            /**
             * 1.祖先类（爷爷级以上）都必须调用Cloneable接口
             * 2.重写clone方法（如果有爷爷以上，则每个祖先都要重写），祖先全都克隆一遍，依次连接新克隆的对象
             * 3.返回值
             */

        }

        //包装类
        {        /**
         * 包装类:基本数据类型所对应的类类型
         * byte = Byte
         * short = Short
         * int = Integer     *
         * long = Long
         * float = Float
         * double = Double
         * char = Character  *
         * boolean = Boolean
         */

        /*包装类的使用*/
        /**
         * 装箱:将一个基本数据类型转成包装类
         * 自动装箱:Integer val = a;
         * 显式装箱:
         * 1.Integer val = Integer.valueOf(a);
         * 2.Integer val = new Integer(a);
         *
         * 拆箱:将包装类转成基本数据类型
         * 自动拆箱:
         * 1.int a = val;
         * 2.int a = (int)val;
         * 显式拆箱:
         * 1.int a = val.intValue();
         *
         * Integer包装类中,装包有个-127<i<128的cache数组(缓存),cache存了256个数字
         * 如果装包不超过这个大小,则进缓存.否则new一个包装类
         */



        }















































































    }

}








